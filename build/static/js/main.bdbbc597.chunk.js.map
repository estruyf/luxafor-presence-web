{"version":3,"sources":["models/index.ts","models/Availability.ts","services/AuthProvider.tsx","services/auth-utils.tsx","services/Luxafor.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Availability","C","fetchMsGraph","url","accessToken","a","fetch","headers","Authorization","response","json","isIE","ua","window","navigator","userAgent","msie","indexOf","msie11","GRAPH_ENDPOINTS","GRAPH_REQUESTS","LOGIN","scopes","PRESENCE","msalApp","UserAgentApplication","auth","clientId","authority","validateAuthority","postLogoutRedirectUri","navigateToLoginRequestUrl","cache","cacheLocation","storeAuthStateInCookie","system","navigateFrameWait","logger","error","console","errorPii","info","log","infoPii","verbose","verbosePii","warning","warn","warningPii","useRedirectFlow","Luxafor","deviceId","presence","color","Available","AvailableIdle","Away","BeRightBack","Busy","BusyIdle","DoNotDisturb","Offline","PresenceUnknown","body","userId","actionFields","custom_color","method","JSON","stringify","data","ok","localStorage","getItem","setItem","AuthProvider","props","useState","setColor","setPresence","getDeviceId","setDeviceId","nrOfMinutes","setMinutes","account","then","className","onClick","onSignOut","onSignIn","value","placeholder","onChange","newIdInput","target","type","e","refreshUpdate","style","backgroundColor","authCalled","refreshTimer","queryPresence","acquireToken","token","setState","message","availability","setTimeout","updateRefresh","parseInt","isNaN","clearTimeout","state","handleRedirectCallback","errorMessage","getAccount","this","request","redirect","acquireTokenSilent","errorCode","length","acquireTokenRedirect","acquireTokenPopup","loginRedirect","loginPopup","catch","loginResponse","logout","Component","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.bdbbc597.chunk.js","sourcesContent":["export * from './Availability';\nexport * from './Presence';\n","export enum Availability {\n  Available = \"Available\", \n  AvailableIdle = \"AvailableIdle\", \n  Away = \"Away\", \n  BeRightBack = \"BeRightBack\", \n  Busy = \"Busy\",\n  BusyIdle = \"BusyIdle\", \n  DoNotDisturb = \"DoNotDisturb\", \n  Offline = \"Offline\",\n  PresenceUnknown = \"PresenceUnknown\"\n}","import React, { Component } from \"react\";\nimport {\n  msalApp,\n  requiresInteraction,\n  fetchMsGraph,\n  isIE,\n  GRAPH_ENDPOINTS,\n  GRAPH_REQUESTS\n} from \"./auth-utils\";\nimport { Account } from \"msal\";\nimport { Presence } from \"../models\";\n\n// If you support IE, our recommendation is that you sign-in using Redirect APIs\nconst useRedirectFlow = isIE();\n// const useRedirectFlow = true;\n\nexport interface AuthProviderProps {}\n\nexport interface AuthProviderState {\n  account: Account | null;\n  error: string | null;\n  presence: string | null;\n}\n\nexport default (C: any) => class AuthProvider extends Component<AuthProviderProps, AuthProviderState> {\n  private authCalled: boolean = false;\n  private nrOfMinutes: number = 2;\n  private refreshTimer: any;\n  \n  constructor(props: AuthProviderProps) {\n    super(props);\n    \n    this.state = {\n      account: null,\n      error: null,\n      presence: null\n    };\n  }\n\n  /**\n   * componentDidMount lifecycle hook\n   */\n  public async componentDidMount() {\n    msalApp.handleRedirectCallback((error: any) => {\n      if (error) {\n        const errorMessage = error.errorMessage ? error.errorMessage : \"Unable to acquire access token.\";\n        // setState works as long as navigateToLoginRequestUrl: false\n        this.setState({\n          error: errorMessage\n        });\n      }\n    });\n    \n    const account = msalApp.getAccount();\n    \n    this.setState({\n      account\n    });\n    \n    if (account) {\n      this.queryPresence(useRedirectFlow);\n    }\n  }\n  \n  /**\n   * Acquire token\n   * \n   * @param request \n   * @param redirect \n   */\n  public async acquireToken(request: any, redirect?: boolean) {\n    try {\n      return await msalApp.acquireTokenSilent(request);\n    } catch (error) {\n      // Call acquireTokenPopup (popup window) in case of acquireTokenSilent failure\n      // due to consent or interaction required ONLY\n      if (requiresInteraction(error.errorCode)) {\n        return redirect ? msalApp.acquireTokenRedirect(request) : msalApp.acquireTokenPopup(request);\n      } else {\n        console.error('Non-interactive error:', error.errorCode)\n      }\n    }\n  }\n  \n  /**\n   * Sign in the user\n   * \n   * @param redirect \n   */\n  public async onSignIn(redirect: boolean) {\n    if (this.authCalled) {\n      return;\n    }\n\n    this.authCalled = true;\n\n    if (redirect) {\n      return msalApp.loginRedirect(GRAPH_REQUESTS.PRESENCE);\n    }\n    \n    const loginResponse = await msalApp.loginPopup(GRAPH_REQUESTS.PRESENCE).catch(error => {\n      this.setState({\n        error: error.message\n      });\n    });\n\n    if (loginResponse) {\n      this.setState({\n        account: loginResponse.account,\n        error: null\n      });\n\n      this.queryPresence();\n    }\n  }\n\n  /**\n   * Start querying the MS graph for the presence\n   * \n   * @param fetchMsGraph \n   */\n  public queryPresence = async (useRedirectFlow?: boolean) => {\n    try {\n      let token;\n\n      try {\n        token = await this.acquireToken(GRAPH_REQUESTS.PRESENCE, useRedirectFlow);\n      } catch (error) {\n        this.setState({\n          error: error.message\n        });\n        return;\n      }\n\n\n      if (token) {\n        const presence: Presence = await fetchMsGraph(GRAPH_ENDPOINTS.PRESENCE, token.accessToken);\n        if (presence && presence.availability) {\n          this.setState({\n            presence: presence.availability\n          });\n        }\n      }\n    } catch (error) {\n      this.setState({\n        error: \"Unable to fetch Graph profile.\"\n      });\n    }\n    \n    this.refreshTimer = setTimeout(() => {\n      this.queryPresence();\n    }, this.nrOfMinutes * 60 * 1000);\n  }\n     \n  /**\n   * Sign out the user\n   */\n  public onSignOut() {\n    msalApp.logout();\n\n    if (this.refreshTimer) {\n      clearTimeout(this.refreshTimer);\n      this.refreshTimer = null;\n    }\n  }\n\n  public updateRefresh = (nrOfMinutes: string) => {\n    const value = parseInt(nrOfMinutes);\n    if (!isNaN(value) && value) {\n      if (this.refreshTimer) {\n        clearTimeout(this.refreshTimer);\n        this.refreshTimer = null;\n      }\n\n      this.refreshTimer = setTimeout(() => {\n        this.queryPresence();\n      }, value * 60 * 1000);\n    }\n  }\n      \n  /**\n   * Render the authentication component as a wrapper for the APP\n   */\n  render() {\n    return (\n      <C {...this.props}\n         account={this.state.account}\n         error={this.state.error}\n         presence={this.state.presence}\n         onSignIn={() => this.onSignIn(useRedirectFlow)}\n         onSignOut={() => this.onSignOut()}\n         refreshUpdate={this.updateRefresh} />\n    );\n  }\n};","import { UserAgentApplication, Configuration } from \"msal\";\n\nexport const requiresInteraction = (errorMessage: any) => {\n  if (!errorMessage || !errorMessage.length) {\n    return false;\n  }\n  \n  return (\n    errorMessage.indexOf(\"consent_required\") > -1 ||\n    errorMessage.indexOf(\"interaction_required\") > -1 ||\n    errorMessage.indexOf(\"login_required\") > -1\n  );\n};\n  \nexport const fetchMsGraph = async (url: string, accessToken: string) => {\n  const response = await fetch(url, {\n    headers: {\n      Authorization: `Bearer ${accessToken}`\n    }\n  });\n  \n  return response.json();\n};\n  \nexport const isIE = (): boolean => {\n  const ua = window.navigator.userAgent;\n  const msie = ua.indexOf(\"MSIE \") > -1;\n  const msie11 = ua.indexOf(\"Trident/\") > -1;\n  \n  // If you as a developer are testing using Edge InPrivate mode, please add \"isEdge\" to the if check\n  // const isEdge = ua.indexOf(\"Edge/\") > -1;\n  \n  return msie || msie11;\n};\n  \nexport const GRAPH_SCOPES = {\n  OPENID: \"openid\",\n  PROFILE: \"profile\",\n  USER_READ: \"User.Read\",\n  PRESENCE_READ: \"Presence.Read\"\n};\n  \nexport const GRAPH_ENDPOINTS = {\n  ME: \"https://graph.microsoft.com/v1.0/me\",\n  PRESENCE: \"https://graph.microsoft.com/beta/me/presence\"\n};\n  \nexport const GRAPH_REQUESTS = {\n  LOGIN: {\n    scopes: [\n      GRAPH_SCOPES.OPENID,\n      GRAPH_SCOPES.PROFILE,\n      GRAPH_SCOPES.USER_READ\n    ]\n  },\n  PRESENCE: {\n    scopes: [GRAPH_SCOPES.PRESENCE_READ]\n  }\n};\n  \nexport const msalApp = new UserAgentApplication({\n  auth: {\n    clientId: \"66204339-daf1-40fa-aa31-57342272edce\",\n    authority: \"https://login.microsoftonline.com/1a8ddc4e-a051-46a5-b1a2-0438a5f7f8c4\",\n    validateAuthority: true,\n    postLogoutRedirectUri: \"https://luxafor-presence.azurewebsites.net\",\n    navigateToLoginRequestUrl: false\n  },\n  cache: {\n    cacheLocation: \"sessionStorage\",\n    storeAuthStateInCookie: isIE()\n  },\n  system: {\n    navigateFrameWait: 0,\n    logger: {\n      error: console.error,\n      errorPii: console.error,\n      info: console.log,\n      infoPii: console.log,\n      verbose: console.log,\n      verbosePii: console.log,\n      warning: console.warn,\n      warningPii: console.warn\n    }\n  }\n} as Configuration);","import { Availability } from \"../models\";\n\nexport const DEFAULT_COLOR = \"000000\";\nexport const API_URL = \"/api/setColor\";\n\nexport default class Luxafor {\n\n  public static async setColor(deviceId: string, presence: string): Promise<string> {\n    let color: string = DEFAULT_COLOR;\n\n    if (!deviceId || !presence) {\n      return color;\n    }\n    \n    switch(presence) {\n      case Availability.Available:\n      case Availability.AvailableIdle:\n        color = \"008000\";\n        break;\n      case Availability.Away:\n      case Availability.BeRightBack:\n        color = \"B2B200\";\n        break;\n      case Availability.Busy:\n      case Availability.BusyIdle:\n      case Availability.DoNotDisturb:\n        color = \"990000\";\n        break;\n      case Availability.Offline:\n      case Availability.PresenceUnknown:\n      default:\n        color = DEFAULT_COLOR;\n        break;\n    }\n\n    const body = {\n      userId: deviceId,\n      actionFields: {\n        color: \"custom\",\n        custom_color: color\n      }\n    };\n\n    const data = await fetch(API_URL, {\n      method: \"POST\",\n      headers: {\n        \"content-type\": \"application/json\",\n        \"accept\": \"application/json\"\n      },\n      body: JSON.stringify(body)\n    });\n\n    if (data && data.ok) {\n      return color;\n    } else {\n      return DEFAULT_COLOR;\n    }\n  }\n\n  public static getDeviceId(): string {\n    if (localStorage) {\n      return localStorage.getItem(\"Luxafor:Device:ID\") || \"\";\n    }\n    return \"\";\n  }\n\n  public static setDeviceId(deviceId: string): void {\n    if (localStorage) {\n      localStorage.setItem(\"Luxafor:Device:ID\", deviceId);\n    }\n  }\n}","import React, { useState } from 'react';\nimport './App.css';\nimport AuthProvider, { AuthProviderState } from \"./services/AuthProvider\";\nimport Luxafor, { DEFAULT_COLOR } from \"./services/Luxafor\";\n\n// TODO: Specify the ID of the Luxafor device\n\ninterface AppProps extends AuthProviderState {\n  onSignIn: () => void;\n  onSignOut: () => void;\n  refreshUpdate: (nrOfMinutes: string) => void;\n}\n\nconst App = (props: AppProps) => {\n  // const [authCalled, setAuthCalled] = useState(false);\n  const [color, setColor] = useState(DEFAULT_COLOR);\n  const [presence, setPresence] = useState(\"\");\n  const [deviceId, setDeviceId] = useState(Luxafor.getDeviceId());\n  const [nrOfMinutes, setMinutes] = useState(\"2\");\n\n  if (!props.account) {\n    // props.onSignIn();\n  }\n\n  const deviceChange = (newIdInput: React.ChangeEvent<HTMLInputElement>) => {\n    if (newIdInput && newIdInput.target && newIdInput.target.value) {\n      Luxafor.setDeviceId(newIdInput.target.value);\n      setDeviceId(newIdInput.target.value);\n    }\n  };\n\n  if (deviceId && props.presence && presence !== props.presence) {\n    Luxafor.setColor(deviceId, props.presence as string).then(color => {\n      setColor(color);\n      setPresence(props.presence as string);\n    });\n  }\n\n  return (\n    <div className=\"App\">\n      <section className=\"App-login\">\n        {!props.account ? (\n          <button onClick={props.onSignIn}>Sign In</button>\n        ) : (\n          <button onClick={props.onSignOut}>Sign Out</button>\n        )}\n\n        <input value={deviceId} placeholder=\"Device ID\" onChange={deviceChange} />\n        <input value={nrOfMinutes} placeholder=\"Refresh rate in minutes\" type=\"number\" onChange={e => {\n          props.refreshUpdate(e.target.value);\n          setMinutes(e.target.value);\n        }} />\n      </section>\n\n      <header className=\"App-header\" style={{\n        backgroundColor: `#${color}`\n      }} >\n        <h1>Luxafor - Presence</h1>\n        { props.presence && <h2>{props.presence}</h2> }\n      </header>\n    </div>\n  );\n};\n\nexport default AuthProvider(App);\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}